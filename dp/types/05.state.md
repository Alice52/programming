[toc]

## target

1. 将所有状态集中管理`[enum]`: 不能使其散落在代码流程中
2. 开闭原则: 尽量做到不影响已有逻辑进行扩展
3. core point:

   - 内部流转及限制: 限制具体的实现类内做{状态间认识约束} | 客户端在 context 中做{使用者限制约束}
   - 可以是不同行为(不同任务): 不同的实现类, 每个实现类都像一个完全新的类

## 状态模式 - state

1. intros: `状态 - 流转{流转限制} - 行为{该状态下可进行的操作}`

   - 定义: 对**有状态**的对象, 把复杂的 `判断逻辑` 提取到**不同的状态对象**中, 允许状态对象**在其内部状态发生改变**时改变其行为
   - 释义: 当一个对象内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类
   - 释义: 对象在状态流转过程中是有一些限制的, 传统的 if/else/switch 也可以实现但是破坏性不较大{不方便扩展}, 阅读性不好

2. pros

   - **将某一状态的所有行为内聚到一个类中, 降低代码复杂度**: 该状态下可以进行的所有操作都在这, **扩展/修改**也在这里`{容易维护该状态操作}`
   - 将不同状态可以进行的操作隔离开, 使用是将其与上下文结合就可使用

3. cons

   - 将不同状态的行为隔离开会导致类的数量增加 | 结构复杂 | 代码的可读性降低
   - 如果有新的状态加入就会改到所有的类: 违法开闭原则`{新增一个状态, 可能会涉及带其他类的向此状态的流转}`
   - 不同状态下可能会有重复代码: 抽象父类 | 组合辅助类 | 状态的二次方

4. types

   - state: 状态模式
   - finite state machine(**有限状态机**): `现态 - 事件 - 动作(逻辑) - 次态`
     ![avatar](/static/image/dp/dp-state-machine.png)

## uml 图

1. roles

   - 上下文角色: 持有一个当前状态, 并将与状态相关的操作**委托给当前状态对象**来处理
     1. 现行的 web 等服务都是无状态的, 所以 context 意义不大: 每次请求结束上下文就没有意义了 , **一般直接 map**
     2. 所以导致用的不多, 趋同与策略模式
   - 抽象状态角色: 提供抽象能力(行为)
   - 具体状态角色: **该状态可进行的所有操作内聚到一起** || 提供方法改变上下文中持有的状态 || 每个具体的状态角色都已有完全不同的行为

2. diagram

   ![avatar](/static/image/dp/dp-state-diagram.png)

3. 举例

   - 物理: 文本|画图器, 选择粗体之后就会是粗体字
   - 简述: 允许在状态更改时更改类的行为

## 适应场景: _很少使用_

1. 业务层面: 流程受状态影响比较大 `{不同状态下可进行的操作不同} | {流转有控制}`, **且需要一定的扩展性**: 比如工作流 | oa 请假等
2. 技术层面: 一个类的多个方法都受到同一状态的影响
3. 技术层面: 很多 if/else/switch/case 的条件是对象状态时, 可以抽象为状态模式

## 实现过程

1. best practice

   ```java
   // 1. context map

   // 2. abstract interface
   IOrderState

   // 3. impl and change state
   UnPayedOrderState
   PayedOrderState
   DeliveryOrderState
   ```

## 经典使用举例

1. jdk
2. spring
3. 自使用
   - 状态模式: `接单, 出库, 运输, 送货, 收货, 评价` + 状态依次流转, 且每个状态下的行为完全不同
   - oa 请假流程:

## notice

1. ~~state vs strategy~~

   - ~~策略模式定义了一组**可互相代**替的算法, 这一组算法对象完成的是**同一个任务**: 可互相代 + 同一个任务~~
   - ~~状态模式**不同的状态完成的任务完全不一样**, 偏向于对象内部状态流转及带来的行为变化: 内部流转(限制) + 可以是不同行为(不同任务)~~
   - ~~[same] 状态模式在没有状态流转的情况下就和策略模式差不多, 都是在某些条件(状态)下, 使用其对应的处理逻辑, 但策略模式更加自动智能一些(会维护条件与策略实现的关系), 状态模式上下文中不维护关系~~

2. 和 strategy 有些类似但不同: 都是根据条件(status)做某些任务(if/else/switch)

   - strategy: 可替换的一组实现 + 相同任务 + context 持有条件和实现的映射关系
   - state: 对象内部的状态流转(带来的行为不同) + 可以是不同的任务 + 状态流转控制 + context 没有持有映射关系
   - 没有 state 流转的情况下, state 就是简易版 strategy: 条件就是 status + 没有映射关系

## reference

1. https://zhuanlan.zhihu.com/p/369732910
2. https://github.com/Alice52/Alice52/files/7326309/-day06.pdf
3. [geekbang-dp]()
4. [状态机-video](https://www.bilibili.com/video/BV1A341137FZ)
5. [状态机-video](https://www.bilibili.com/video/BV1HB4y1R7Su)
6. [状态机-video](https://www.bilibili.com/video/BV1WU4y1S7uU)
7. [状态机-video](https://www.bilibili.com/video/BV1QT411K7Da)
8. [状态机-video](https://www.bilibili.com/video/BV1Bg411d7Gh)
9. [状态机-video](https://www.bilibili.com/video/BV1GT4y1r7uZ)
