[toc]

## target

1. 将所有状态集中管理: 不能使其散落在代码流程中(某个类或某些 package 下的实现类)
2. 开闭原则: 尽量做到不影响已有逻辑进行扩展
3. core point:

   - 内部流转及限制: 2
   - 动作与事件的关系: 3
   - 与策略模式的区别: 3
   - 实现: **事件**触发的状态**转移**和**动作**执行, 拆分到不同的状态类中, 来避免分支判断逻辑

## 状态模式 - state

1. intros: `状态 - 流转{流转限制} - 行为{该状态下可进行的操作}`

   - 定义: 对**有状态**的对象, 把复杂的 `判断逻辑` 提取到**不同的状态对象**中, 允许状态对象**在其内部状态发生改变**时改变其行为
   - 释义: 当一个对象内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类
   - 释义: 对象在状态流转过程中是有一些限制的, 传统的 if/else/switch 也可以实现但是破坏性不较大{不方便扩展}, 阅读性不好

2. pros

   - **将某一状态的所有行为内聚到一个类中, 降低代码复杂度**: 该状态下可以进行的所有操作都在这, **扩展/修改**也在这里`{容易维护该状态操作}`
   - 将不同状态可以进行的操作隔离开, 使用是将其与上下文结合就可使用

3. cons

   - 将不同状态的行为隔离开会导致类的数量增加 | 结构复杂 | 代码的可读性降低
   - 如果有新的状态加入就会改到所有的类: 违法开闭原则`{新增一个状态, 可能会涉及带其他类的向此状态的流转}`
   - 不同状态下可能会有重复代码: 抽象父类 | 组合辅助类 | 状态的二次方

4. state and fsm(有限状态机): `现态 - 事件 - 动作(逻辑|流转{限制|时机}) - 次态{该状态下行为像另外的类}`

   ![avatar](/static/image/dp/dp-state-machine.png)

   - `现态 + 事件 = 次态`
   - fsm 是 state 的一种特例; 也可以说 state 是对 fsm 的一种实现

   - 流转: 限制在具体的实现类内做{状态间认识约束}
   - 流转: 在客户端 context 中做{使用者限制约束}

   - 动作可以理解为事件的延续
   - 动作: 可以嵌套在事件的枚举类内
   - 动作: 抽象接口与对应的实现类
   - 动作: 可以发布事件, 然后订阅事件

## uml 图

1. roles

   - 上下文角色: 持有一个当前状态, 并将与状态相关的操作**委托给当前状态对象**来处理
     1. 现行的 web 等服务都是无状态的, 所以 context 意义不大: 每次请求结束上下文就没有意义了 , **一般直接 map**
     2. 所以导致用的不多, 趋同与策略模式
   - 抽象状态角色: 提供抽象能力(行为)
   - 具体状态角色: **该状态可进行的所有操作内聚到一起** || 提供方法改变上下文中持有的状态 || 每个具体的状态角色都已有完全不同的行为

2. diagram

   ![avatar](/static/image/dp/dp-state-diagram.png)

3. 举例

   - 物理: 文本|画图器, 选择粗体之后就会是粗体字 || 超级马里奥的不同状态
   - 简述: 允许在状态更改时更改类的行为

## 适应场景: _很少使用_

1. 业务层面: 流程受状态影响比较大 `{不同状态下可进行的操作不同} | {流转有控制}`, **且需要一定的扩展性**: 比如工作流 | oa 请假 | 游戏等
2. 技术层面: 一个类的多个方法都受到同一状态的影响
3. 技术层面: 很多 if/else/switch/case 的条件是对象状态时, 可以抽象为状态模式
4. 状态机比较简单(少), 但是状态转移发生的逻辑比较复杂, 推荐状态模式, 比如电商下单 | 外卖下单

## 实现过程

1. best practice: 事件触发的状态转移和动作执行, 拆分到不同的状态类中, 来避免分支判断逻辑

   - state transfer in context

     ```java
     /**
     * 1. intros
     *     - JdLogisticsContext: 持有某一种状态对象, 将行为委托给状态对象执行{context 有 doAction(), 但是会调用 state 执行}
     *     - LogisticsState: 抽象行为方法, 预期在 context 中修改 state, 所以不需要持有 context 对象
     *     - LogisticsStateImpl1 | LogisticsStateImpl2: 不同的状态实现, 该状态可进行的所有操作内聚到一起
     *     - StateClient: 测试实例
     * 2. 状态流转控制
     *     - 也可以在 client 中通过给 context 传递不同状态实现来做不同的事情
     * 3. 不同状态的行为可以完全不一样{像不同的类}
     *    - LogisticsStateImpl1 状态下可进行的操作完全不同: 也可以具有一些独立的行为
     */

     // 1. context map: 此处可以该对象状态
     // 2. abstract class
     BaseOrderState
     // 3. impl and change state: 此处可以该对象状态
     UnPayedOrderState
     PayedOrderState
     DeliveryOrderState
     ```

   - state transfer in impl state:

     ```java
     /**
     * 1. intros
     *     - Context: 持有某一种状态对象, 将行为委托给状态对象执行{context 有 open(), 但是会调用 state 执行}
     *     - LiftState: 抽象行为方法, 持有 context 对象(在具体的实现类中修改状态)
     *     - ClosingState | OpenningState | RunningState | StoppingState: 不同的状态实现
     *     - Client: 测试实例
     * 2. 状态流转控制
     *     - 此时的状态流转限制是在具体的实现类中控制的
     * 3. 不同状态的行为可以完全不一样{像不同的类}
     *    - ClosingState 状态下可进行的操作完全不同: 也可以具有一些独立的行为
     */
     ```

2. 状态机:
   - 分支法: 如果一个简单的状态机, 可以使用分支逻辑进行; 但对复杂的来说, 极易漏写或者错写某个状态转移|修改困难
   - ~~查表法~~: 状态机比较复杂(多), 但是状态转移发生的逻辑比较简单, 推荐使用查表法, 比如游戏
   - enum 可以处理简单的状态机流转: 比如获取下一状态 | 指定对应的逻辑
   - 复杂时, 还是需要使用 `现态 - 事件 - 动作(逻辑) - 次态` 进行: 现态与事件(动作)作为 Map 的键, 确定下一状态活执行的逻辑
     ```java
     /**
     * 1. 现态<br>
     * 2. 事件<br>
     * 3. 动作<br>
     *   - 可以嵌套在事件的枚举类内
     *   - 抽象接口与对应的实现类
     *   - 可以发布事件,然后订阅事件
     * 4. 次态<br>
     */
     ```

## 经典使用举例

1. jdk
2. spring
3. 自使用
   - 状态模式: `接单, 出库, 运输, 送货, 收货, 评价` + 状态依次流转, 且每个状态下的行为完全不同
   - oa 请假流程:
   - 超级马里奥的
     1. 游戏情节(吃蘑菇)就是状态机中的`事件`
     2. 加减积分就是状态机中的 `动作`
     3. 吃蘑菇这个事件, 会触发状态的转移: 从小马里奥转移到超级马里奥, 以及触发动作的执行(增加 100 积分)

## notice

1. ~~state vs strategy~~

   - ~~策略模式定义了一组**可互相代**替的算法, 这一组算法对象完成的是**同一个任务**: 可互相代 + 同一个任务~~
   - ~~状态模式**不同的状态完成的任务完全不一样**, 偏向于对象内部状态流转及带来的行为变化: 内部流转(限制) + 可以是不同行为(不同任务)~~
   - ~~[same] 状态模式在没有状态流转的情况下就和策略模式差不多, 都是在某些条件(状态)下, 使用其对应的处理逻辑, 但策略模式更加自动智能一些(会维护条件与策略实现的关系), 状态模式上下文中不维护关系~~

2. 和 strategy 有些类似但不同: 都是根据条件(status)做某些任务(if/else/switch)

   - strategy: 可替换的一组实现 + 相同任务 + context 持有条件和实现的映射关系
   - state: 对象内部的状态流转(带来的行为不同) + 可以是不同的任务(不同的逻辑) + 状态流转控制 + context 没有持有映射关系
   - 没有 state 流转的情况下, state 就是简易版 strategy: 条件就是 status + 没有映射关系

## reference

1. https://zhuanlan.zhihu.com/p/369732910
2. https://github.com/Alice52/Alice52/files/7326309/-day06.pdf
3. [geekbang-dp](https://www.aliyundrive.com/drive/folder/62008661f37d5fd3b1df40a38d9108c4234f1dca)
4. [状态机-video](https://www.bilibili.com/video/BV1A341137FZ)
5. [状态机-video](https://www.bilibili.com/video/BV1HB4y1R7Su)
6. [状态机-video](https://www.bilibili.com/video/BV1WU4y1S7uU)
7. [状态机-video](https://www.bilibili.com/video/BV1QT411K7Da)
8. [状态机-video](https://www.bilibili.com/video/BV1Bg411d7Gh)
9. [状态机-video](https://www.bilibili.com/video/BV1GT4y1r7uZ)
