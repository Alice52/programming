[toc]

## overview

## 迭代器模式

1. intros

   - 定义: 提供顺序访问聚合(集合)对象中的方式, 而**不暴露**聚合对象的内部表示
   - iterator#remove()问题

2. feature

   - 可以为集合提供不同的遍历方式: 比如图的前序遍历, 中序遍历等
   - 可以统一不同数据结构的遍历方式: ArrayList | LinkedList
   - 封装|易用性: 无须暴露其内部细节(封装复杂), 方便使用

3. pros & cons

   - 职责单一: 将遍历的功能解耦到迭代器
   - 方便使用: 可以定义不同规则的迭代器
   - 开闭原则: 定义信的迭代器不需要修改其他
   - 类的数量增加: 可以使用内部类

## uml 图

1. roles

   - 抽象聚合角色: crud 聚合元素 + 创建迭代器对象的接口
   - 具体聚合角色: 实现抽象聚合类 + 返回一个具体迭代器的实例(一般迭代器实现都是内部类)
   - 抽象迭代器角色: 定义访问和遍历集合的接口{hasNext() | next() | currentItem()}
   - 具体迭代器角色: 实现抽象迭代器角色(记录遍历的当前位)

1. uml

   ![avatar](/static/image/dp/iterator-uml.png)

1. explain

   - Real world example
   - In plain words

## 适应场景

1. sdk 中使用, 一般自己甚少使用
2. 聚合对象提供多种遍历方式时: 定义不同的 Iterator
3. 当需要为遍历不同的聚合结构提供一个统一的接口时: ArrayList | LinkedList
4. 当访问一个聚合对象的内容而无须暴露其内部细节的表示时

## 实现过程

## 经典使用举例

1. jdk

   - arraylist#itr
     ```java
     List: 抽象聚合类
     ArrayList: 具体的聚合类 + list.iterator() 具体迭代器对象
     Iterator: 抽象迭代器
     ArrayList#Itr{Iterator}
     ArrayList#ListItr{Itr{Iterator}}
     ```

2. spring
3. working sample

## relative

1. 遍历的方式(java): for-index, iterator(foreach 底层就是 iterator)

## reference

1. https://github.com/Alice52/Alice52/files/7326309/-day06.pdf
2. https://www.aliyundrive.com/drive/folder/62008661f37d5fd3b1df40a38d9108c4234f1dca
