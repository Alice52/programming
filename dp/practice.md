[toc]

## 核心诠释: uml+目的+适应场景

- 扩展: 模板方法 + 观察者模式 + 责任链 + _策略_

### 创建型

1. 单例模式: 为了创建全局唯一的的对象 + 8 种实现 + 线程安全 + 唯一性范围(保证唯一)
2. 工厂模式: 解耦对象创建和使用, 创建复杂{2}对象 + 简单工厂|工厂模式 + 场景{3, 2}
   - 工厂偏向于创建一组不同但是相关的{整体}对象{继承 IFactory[无就是简单工厂], 将实现延迟到子类}
   - 根据参数创建对应对象[可以使用 Map]
3. 抽象工厂模式: 工厂模式 + 产品簇
4. 建造者模式: 详细控制 + `@Builder=静态公开内部类+全量构造函数`
   - 建造者创建一个可定制化的复杂对象: 核心关注部件的细节创建
5. 原型模式: 快速创建成本{2}极大的对象 + 深浅克隆

### 结构型: wrapper{4}

1. 代理模式{2}: {不需要一个一个写}非功能性`{访问, 控制, 扩展}`的公用逻辑处理 + jdk-proxy | cglib + ~~多通过代码层面持有被代理对象实现~~
2. 适配器模式: 补偿接口不兼容{6} + 通过继承/持有对象实现{接口适配器}
3. _桥接模式{2}_:
   - 组合优于继承: 解决继承带来的类爆炸问题, 一个类存在两个及以上变化维度, 通过让一方持有另一方让两个维度独立扩展, 将关系延迟到创建时指定
   - 抽象与实现解耦{lib(jdbc/driver) 级别的}, 独立开发{目的是将接口部分和实现部分分离, 从而让它们可以较为容易、也相对独立地加以改变}
4. 装饰者模式{2}: 解决继承导致的复杂关系|类爆炸 + 对原始类功能进行**增强{每个都要自己写}** + 装饰器类和原始类继承同样的父类{多嵌套} + 线程池异常处理|io
5. 外观模式{2}: 为子系统提供一组统一的接口
6. _组合模式{2}_: 将一组对象处理成树形结构, 来表示部分(叶子节点)与整体(非叶子节点-递归实现)的概念, 通过递归统一处理接口
7. 享元模式: 为了节约内存 + Integer.valueOf | String 的常量池

### 行为型

1. 模板方法模式: 为了代码复用|扩展 + 继承{延迟到子类实现}|callback 实现
2. 策略模式: 解耦策略的定义, 创建, 使用
   - 为了代码复用|扩展 + 定义一组可相互替换的**算法**, 将不同算法独立拆分组织
3. 迭代器模式:
   - 用来遍历集合{遍历操作独立出来, 职责单一|开闭|接口} + 容器和容器迭代器{hasNext()、currentItem()、next()}
   - 容器中创建迭代器: 具体迭代器实现一般都是私有普通非静态内部类
   - 遍历时删除
4. 状态模式:
   - **事件**触发的状态**转移**和**动作**执行, 拆分到不同的状态类中, 来避免分支判断逻辑
   - `{现态 - 事件 - 动作(逻辑|流转{限制|时机}) - 次态{该状态下行为像另外的类}`
   - 无状态下使用不多{restful 却是无状态}
5. 责任链模式: 将请求的发送与接收对象{处理}解耦 + 将接收的请求依次经过接收对象处理器{职责单一|扩展|复杂小类}的处理{默认是有一个能处理就停止}
6. _命令模式_:
   - 本质上是将函数封装成对象
   - 将命令请求封装成对象{将不同请求依赖注入到其他对象}, 用来控制命令的执行{排队, 撤销, 记录, 异步, 延迟等}
7. 观察者模式: 解耦观察者与被观察者
   - 对象之间定义一个一对多的依赖: 一般是单向的观察
   - 被观察者持有观察者列表, 被观察者状态修改则依次通知观察者执行逻辑
   - guava-eventbus | mq | rss | 同步/异步
8. _解释器模式_
   - 很少使用: 编译器、规则引擎、正则表达式等特定领域
   - 为某个语言定义它的语法(文法)表示, 并定义一个解释器用来处理这个语法: **将语法解析的工作拆分到各个小类中**
9. 中介模式
   - 定义一个中介对象封装一组对象的交互{来避免对象间的直接交互}, 将对象间的多对多关系转换为一对多: 上帝类{控制顺序}
   - 当参与者之间的交互关系错综复杂, 维护成本很高的时候, 才考虑使用中介模式
10. _备忘录模式/快照模式_
    - **不违背封装**的前提下, 将对象的内部状态保存在对象之外{**副本**}, 以便丢失、撤销、恢复等
    - 备忘录模式更侧重于代码的设计和实现{对于大对象的备份和恢复(全量备份和增量备份相结合, 低频全量备份, 高频增量备)}, 备份更侧重架构设计或产品设计
11. 访问者模式: 将一/多个操作应用到一组对象上{行为的抽象}, 解耦操作和对象本身

---

## 应用

### 创建型

1. 单例模式
2. 工厂模式
3. 抽象工厂模式
4. 建造者模式
5. 原型模式

### 结构型

1. 代理模式
2. 适配器模式
3. 桥接模式
4. 装饰者模式
5. 外观模式
6. 组合模式
7. 享元模式

### 行为型

1. 模板方法模式
2. **策略模式**
3. 迭代器模式
4. 状态模式
5. 责任链模式
6. 命令模式
7. 观察者模式
8. 解释器模式
9. 中介模式
10. 备忘录模式
11. 访问者模式
